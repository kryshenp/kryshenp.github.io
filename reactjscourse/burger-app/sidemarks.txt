----------------------------
113. Setting up the Project

brand new project created with create-react-app

to enable css modules
to be sure that css classes I create in a css file can be scoped to a specific
component in the app so that they are not applied globally when I accidentally
reuse the same css class

for that I need eject the project by 'yarn eject', so I have an access to the config
in the config folder and there to 2 webpack configuration files.

In part where I have CSS test and the css-loader, there i have to add `modules: true,`
to the options of that loader and add `localIdentName: '[name]__[local]__[hash:base64:5]'
option to basically define the css class name it will automatically generate and
assign. This should take the original name then the local name of the component and
then a randomly generated hash. This will generate this unique css classnames, which
are then assign automatically once we import them through that object from the css
file

Then I copy these 2 lines with `modules` and `localIdentName` and copy them to the
config file of the production build.

With that I have my project setup and can get started.

----------------------------
114. Creating a Layout Component

Do some cleanup work:
remove logo svg file which was created automatically and I don't need
and remove its import in the App.js file, and cleanup the appjs content here.
remove the className APP from the root div and remove the App.css import
and remove the app.css file

in index.css I want to use Open Sans font family, choose it form google fonts, customize
it and with the embed link add it to the public/index.html file and add it right above
the title

I created 2 folders components and containers in my src.
Containers are basically stateful components, so typically components created with
the class keyword, whereas components are stateless components - typically fucntional
components

Now I will create a layout in the components folder, cause now I don't need to manange any
state there
So in components I create a subfolder which I name layout and there create Layout.js

Then assets folder where we'll add a logo. For redux store I'll add the folder later.

In Layout.js I create a component with the Toolbar, SideDrawer and Backdrop
then create <main> in which I wrap the component we made in Layout so I'll use
{props.children}. Don't forget to add props as an argument to the function.

then i'll go with the higher order component(hoc) approach and create such utility auxiliary
component. For that I create a new folder `hoc`  in a src folder and there I create Aux.js file

Auxiliary component is a functional stateless component

then i can wrap everything in Layout.js with the <Aux></Aux>. Export the Layout
component.

Now we can use it in the App.js file in our root component. Import Layout.js to the
App.js. Let's wrap a <p> Test with <Layout>.

Then add "Open-Sans" font into index.css. We did add the import to the public folder,
so just simply add the "Open-Sans" font family as a main font to the index.css file.

With that I got a roof of my app finished for now.

P.S. I had a problem with the absence of the `babel-loader` module. I've solved it
by updating node version from `v8.9.4` to `v9.10.0` and rebuild the app ->
`yarn && yarn. start`.

----------------------------
115. Starting Implementation of The Burger Builder Container

Start implementing the burger builder component. This will be a container, because
there I plan of managing the state for the burger.
In the containers folder where I create a new subfolder BurgerBulder and BurgerBulder.js
file and there I create the component with the class keyword, cause I want to manage state
there. I name it BurgerBulder and I need to extend this Component object we can
import from React, I also import React to be able to write jsx.

I need to implement the lifecycle `render` method. This is a must because I must
tell react what I want to render. There I need to some jsx code.

For now I want to render 2 different things (wrapped into <Aux>). For that I can
use my Auxiliary component. Import it. Here I want to return 2 jsoned components
in the end. For now I use <div>s as a placeholders. I want to return a burger I
built - a graphical representation of the burger with all the ingredients, and
below that I want to have my build controls - so basically the area where I
can add or remove the ingredients. This is a basic setup of it.

Now I import BurgerBulder in my App.js file and replace Test with it. BurgerBuilder
can be a self-closing component, I don't need to wrap any content with the
selectors.

Improve some styling. Make some margin between my Toolbar placeholder and other part.
I'll do this in the Layout component because there I have the area for the
Toolbar and the area for the main part. So I simply want to add a css class to
the <main> element there to make sure that it has some margin.
For that I'll add a new css file Layout.css and in that file I'll create a new
class .Content where I add margin-top 16px. Then I import classes from the
Layout.css file to the component. Add className to the <main> element.
className={classes.Content}.

In the next step I add the Burger components and burger ingredients which should
be rendered there.

----------------------------
116. Adding a Dynamic Ingredient Component

In components folder I create a new subfolder `Burger`, where Burger related
things go. Add there a couple of subcomponents, i.e. Burger.js file which should
be a burger we rendering to the screen. For ingredients I create another subfolder
inside of the Burger folder BurgerIngredient/BurgerIngredient.js.

In BurgerIngredient.css there is a code for burger ingredients styles.
Now I fill the BurgerIngredient component with life. Create a finction -
so a stateless component burgerIngredient with some props and return smth. Use
{} cause I want to run some logic before I return jsx (don't forget to import
react cause I want to write some jsx in the end) and of course export this as
default.

I need some logic to render the jsx code. This logic is required cause there are
different types of ingredients and I expect to get the info about which ingr to
render via props.

in burgerIngredient I'll create an ingredient variable and set it to null.
Initially I won't render anything, i.e. if smth invalid is passed in.

Now I'll switch (normal JS switch statement) and analyse to type of my ingredient.
So type is a property I expect to receive. Now I have a couple of different CASE_SENSITIVE
for example a `bread-bottom`. MY ingredient there should be <div> with the
className. For that I need to import my classes from the BurgerIngredient.css file
and assign {classes.BreadBottom} for the ingredient <div>;. then break;
After the break I want to add another case `bread-top`. On this ingredient there
will be some seeds, so here I actually return some multiline. Inside of the .BreadTop
<div> i need 2 other <div>s, which represent the seeds with .Seeds1 and .Seeds2.

 then break again. the next cases are `meat`,`cheese`,`bacon`,`salad`.
 then setup a default case there in case smth incorrect is passed there ->
 ingredient should = null;

after this big switch statement here we can safely the ingredient here.
In the next steps I'll add the propType validation here, cause I want to make
sure that I do receive a type property.

----------------------------
118. Adding Prop Type Validation

Now I can add props type validation. For this I cancel the dev server and then
run `yarn add prop-types`. This package is provided by React team to validate
the prop types of my react properties. Then import PropTypes to the BurgerIngredient
file. Then restart the dev server. I can use PropTypes on components which
are created with the class keyword. In BurgerIngredient I have a stateless component
created as a function. I can simply convert it and this doesn't automatically
turn it into container. It's still dumb stateless component without any
state which now is created with the class keyword. This is an important
thing to understand: I DON'T decide if something is a container or not
with the CLASS keyword, I can create all my components as a CLASS if I
want, it's just a good practice to use FUNCTIONAL form as often as possible.
But it's NOT a must.
With that i renamed const burgerIngredient to class BurgerIngredient, to have
a capital 'B' to follow the naming convention of classes. Also import Component
as a named import from 'react'. So now BurgerIngredient should EXTEND Component:
`class BurgerIngredient extends Component`.
Then I add the class {body} where I need to implement the RENDER method.
Inside render () {} I execute my logic - my switch statement and in the end
return the ingredient. Remove the relict down under the render (), and export
my new BurgerIngredient. props.type won't work because because in class
I need props with this.props.type <- add THIS in front of props.

Now I can add a propType validation by adding a className.propTypes property
with the lowercase 'p' and setting it equal to the JavaScript object. In
my case it'd be BurgerIngredient.propTypes = {}; In this object I want to
configure the type property using the PropTypes I imported from that package.
The type should be a string and I also chain another condition, that it is
required `type: PropTypes.string.isRequired`.So if I ever try to use the
ingredient component without passing a type, i'll get an error. BurgerIngredient
component is basically finished and I want to see it in action, so now I
start to build my burger in the Burger component.

----------------------------
119. Starting the Burger Component

Burger component has been created in the functional form again as a
function named 'burger', which receive some props with curly braces {},
so I can add some JS logic before returning jsx.
For now all I do there is return some jsx though, but I'll revisit this
component to enhance it and conditionally render smth else later.
Because I use jsx I have to import react, and export the default burger.
The jsx in return should simply use the burger ingredients components I
created, but I also want to wrap everything in a <div>, cause it'll be a
wrapper which this burger component essentially is - wrapper around all the
ingredients. I give it some styling to define width and height of the burger.
For that I add a new file Burger.css and there I add the .Burger css class
with some rules for the .Burger wrapper and some @media rules. Import css to
the Burger wrapper component. Then import BurgerIngredient and then use it
as a self-closing component, but I have to define a type.
The type has be a string, cause we implemented propType checking.
For now I'll create a burger of 4 ingredients - bread top, cheese, meat
and bread-bottom. Self-closing components look like this:
<BurgerIngredient type="cheese"/>. As we exported the burger, I can go
to the BurgerBuilder container at `containers/BurgerBuilder/BurgerBuilder.js`
and there replace the dummy <div>Burger</div> with our burger.
First I have to import Burger from components/Burger/Burger and replace
that <div> with the self-closing <Burger /> component.

Not great is that everything about the burger is in the end hardcoded. I'm
using components, but I'm not able to change this burger dynamically and I'm
not even rendering it dynamically. Next work will be with managing the state
and rendering burger dynamically.

----------------------------
120. Outputting Burger Ingredients Dynamically
First important step is handling burger ingredients in the state of our burger
Builder, cause this is where we ultimately edit them to. This is also a reason
why this is a stateful component.
I initialise state as a property. There is also a possibility to add a constructor,
where I receive the props call super with the props and then initialise this.state
'this', cause I'm inside method
constructor(props) {
  super(props);
  this.state = {...}
}
this will also work, this is an alternative. This will be commented out, cause
a bit modern approach with shorter syntax will be used.
Inside a state it will be ingredients object. I'll have KEY-VALUE pairs, where
the keys are the names of the ingredients and the values is the amount. Later I'll
add the more state like a price, but for now let's go with the burger fundamentals.
As I have my ingredients, the goal now is to pass this array to my burger. On the
<Burger /> at the ingredients property I pass {this.state.ingredients}. The thing
is - the burger doesn't receive any ingredients :( yet.
I copy that over to the burger component and want to start outputing the ingredients
dynamically. In the Burger.js component we receiving ingredients as a props, but if
I inspect ingredients in a state of the BurgerBuilder - it's an Object, it's
NOT an array, so I can't use map on that, I can't just loop through that - it's an Object.
Instead I have to transform this Object into an Array. To be precise I have to convert
this Object into an Array of values of the ingredients.
In the burger function in the Burger.js component I'll create a new const, which i name
'transformedIngredients' and there I'll use the Object object. That's default
JavaScript object not provided by React. It has a keys method, which extracts the
keys of a given Object and turns that into an Array - gives me an array of the keys.
const transformedIngredients = Object.keys(props.ingredients); For my objects it gives us an array, which contains
a string salad, string bacon etc. The values 1 1 2 2 are not part of the array.
Into Object.keys I'll pass props.ingredients, now I have that array of keys in the end.
I'll chain a method with the .map method in a new line to be easier to read, which
i can execute since keys returns me an array. .map() executes a function on an
each element in an array. I'll give it an argument I receive in the array 'igKey'
for ingredient key, cause that is what jus part of the array is. In that function
here I want to transform this string value into an array of as many elements as
I have in the ingredients for a given ingredient 4:46. 
